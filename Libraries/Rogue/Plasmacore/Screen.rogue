module Plasmacore


class Screen
  PROPERTIES
    state                 = ScreenState(this)
    #layers                = Layer[]

    display               : Display
    is_active             : Logical
    needs_first_update    = true
    previous_display_size : XY?

    loaded_asset_count    : Int32
    total_asset_count     : Int32

    lighting : Lighting
    # 3D lighting model

    actions  : Action

    transition_info : TransitionInfo?

  METHODS
    #method add( layer:Layer )->this
    #  layers.add( layer )
    #  return this

    method after( e:KeyEvent )

    method after( e:PointerEvent )

    method after( e:ScrollEvent )

    method after( e:TextEvent )

    method after_draw

    method after_resize

    method after_update

    method change_state( new_state:ScreenState )->ScreenState
      local cur = new_state
      while (cur.next_state) cur = cur.next_state
      cur.next_state = state.next_state
      state.next_state = null
      new_state.prior_state = state.prior_state

      new_state.on_prepare
      state.on_finish
      state.is_active = false
      @state = new_state
      state.screen = this
      state.is_active = true
      state.on_start
      return state

    method change_screen( new_screen:Screen )->Screen
      new_screen.display = display
      new_screen.on_prepare
      #forEach (layer in new_screen.layers)
      #  if (layer.is_visible) layer.on_prepare
      #endForEach
      this.on_finish
      #forEach (layer in new_screen.layers)
      #  if (layer.is_visible) layer.on_finish
      #endForEach
      this.is_active = false
      display.screen = new_screen
      return new_screen

    method exit_state
      local new_state : ScreenState
      if (state.next_state)
        new_state = state.next_state
      elseIf (state.prior_state)
        new_state = state.prior_state
      else
        println "ERROR: Screen/ScreenState.exit_state called with no next or prior state"
        new_state = ScreenState()
      endIf

      new_state.screen = this
      new_state.on_prepare

      state.on_finish
      state.is_active = false

      new_state.is_active = true

      if (state.next_state)
        new_state.prior_state = state.prior_state
        @state = new_state
        state.on_start
      elseIf (state.prior_state)
        @state = new_state
        state.on_resume
      else
        @state = new_state
        state.on_start
      endIf

    method handle( e:KeyEvent )
      on( e )
      if (e.is_consumed) return

      #if (layers.count)
      #  forEach (layer in layers step -1)
      #    if (layer.is_visible)
      #      layer.on( e )
      #      if (e.is_consumed) return
      #    endIf
      #  endForEach
      #endIf

      after( e )

    method handle( e:PointerEvent )
      on( e )
      if (e.is_consumed) return

      #if (layers.count)
      #  forEach (layer in layers step -1)
      #    if (layer.is_visible)
      #      layer.on( e )
      #      if (e.is_consumed) return
      #    endIf
      #  endForEach
      #endIf

      after( e )

    method handle( e:ScrollEvent )
      on( e )
      if (e.is_consumed) return

      #if (layers.count)
      #  forEach (layer in layers step -1)
      #    if (layer.is_visible)
      #      layer.on( e )
      #      if (e.is_consumed) return
      #    endIf
      #  endForEach
      #endIf

      after( e )

    method handle( e:TextEvent )
      on( e )
      if (e.is_consumed) return

      #if (layers.count)
      #  forEach (layer in layers step -1)
      #    if (layer.is_visible)
      #      layer.on( e )
      #      if (e.is_consumed) return
      #    endIf
      #  endForEach
      #endIf

      after( e )

    method handle_draw
      on_draw
      #if (layers.count)
      #  forEach (layer in layers)
      #    if (layer.is_visible) layer.on_draw
      #  endForEach
      #endIf
      after_draw

    method handle_resize
      on_resize
      #if (layers.count)
      #  forEach (layer in layers)
      #    if (layer.is_visible) layer.on_resize
      #  endForEach
      #endIf
      after_resize

    method handle_update
      if (actions) actions = actions.update
      on_update
      #if (layers.count)
      #  forEach (layer in layers)
      #    if (layer.actions) layer.actions = layer.actions.update
      #    if (layer.is_visible) layer.on_update
      #  endForEach
      #endIf
      after_update

    method lighting->Lighting
      return (ensure @lighting)

    method on( e:KeyEvent )

    method on( e:PointerEvent )

    method on( e:ScrollEvent )

    method on( e:TextEvent )

    method on_draw

    method on_finish

    method on_prepare

    method on_resize

    method on_start

    method on_transition_after_draw
      local info = transition_info.value
      Display.bounds.fill( info.color.with_alpha(info.eased_progress) )

    method on_transition_before_draw

    method on_update

    method push_state( new_state:ScreenState )
      new_state.prior_state = state
      state.is_active = false
      state.on_suspend
      @state = new_state
      state.screen = this
      state.is_active = true
      state.on_start

    method queue_state( new_state:ScreenState, &insert )
      state.queue_state( new_state, &=insert )

    method set_state( new_state:ScreenState )->this
      change_state( new_state )
      return this

endClass

