# To run this build file, install Rogue from github.com/AbePralle/Rogue and type "rogo" at the command line.

#$ LIBRARIES(macOS) = brew
#$ LIBRARIES(macOS) = gradle
# INACTIVE: brew-installed gradle is currently not working with Android Studio projects.

#$ LIBRARIES(Linux) = gradle
#$ LIBRARIES(Linux) = ninja(install:ninja-build)

#$ LINK_LIBS            = true
#$ LIBRARIES(macOS)     = libjpeg
#$ LIBRARIES(macOS)     = libpng
#$ LIBRARIES(macOS)     = zlib(flags:-lz)
#$ LIBRARIES(Linux-apt) = libjpeg(install:libjpeg-dev)
#$ LIBRARIES(Linux-apt) = libpng(install:libpng-dev)

uses Bitmap
uses DateTime

# description()s are optional - Rogo uses introspection to determine which commands are available.
# 'rogo help default' displays the description for "default", etc.
description( "default", "The default action is performed when no other actions are specified. Use 'rogo default' to explicitly perform the default option." )
description( "help",    "Displays a list of all actions that can be performed by Rogo." )

class Keystore [singleton]
  # Create a BuildLocal.rogue file with:
  #   augment Keystore
  #     METHODS
  #       method init
  #         keystore_filepath = "<Keystore filepath>"
  #         keystore_password = "<Keystore password>"
  #         key_alias         = "<key alias>"
  #         key_password      = "<key password>"
  #   endAugment
  PROPERTIES
    keystore_filepath : String
    keystore_password : String
    key_alias         = "appsign"
    key_password      : String

  METHODS
    method configure
      contingent
        necessary (keystore_filepath)
        necessary (keystore_password)
        necessary (key_password)
      unsatisfied
        println @|-------------------------------------------------------------------------------
                 |No keystore information found in BuildLocal.rogue. Would you like to (c)reate a
                 |new upload keystore or use an (e)xisting keystore?
                 |
        local choice = Console.input( "(c)reate keystore or use (e)xisting? " ).to_lowercase
        which (choice)
          case "c"
            rogo_keystore
          case "e"
            local content = ""
            if (File("BuildLocal.rogue").exists) content = String( File("BuildLocal.rogue") ) + "\n"
            else                                 println "Creating Platforms/Android/BuildLocal.rogue"

            if (not content.contains("augment Keystore"))
              if (content.count > 0) content += "\n"
              content += @|# Uncomment the following and adjust the properties.
                          |#augment Keystore
                          |#  METHODS
                          |#    method init
                          |#      keystore_filepath = "<keystore-filepath>"
                          |#      keystore_password = "<keystore-password>"
                          |#      key_alias         = "<key-alias>"
                          |#      key_password      = "<key-password>"
                          |#endAugment
              File("BuildLocal.rogue").save( content )
            endIf

            println @|Edit keystore filepath and passwords in Platforms/Android/BuildLocal.rogue, then
                     |re-run the current command.
            System.exit
          others
            println "Unsupported option. Exiting."
        endWhich
      endContingent
endClass

routine rogo_clean
  File( "app/build" ).delete
  File( "plasmacore/build" ).delete
endRoutine

routine rogo_default
  rogo_help
endRoutine

description( "icon", "Changes the icon used for by Android." )
routine rogo_icon( new_icon_png:String )
  if (not String.exists(new_icon_png)) throw Error( "PNG filename expected." )
  if (not File(new_icon_png).exists) new_icon_png = "../../" + new_icon_png
  local new_icon = Bitmap( File(new_icon_png) )
  local files = Files( "app/src/main/res", "*/*.png" )
  forEach (filepath in files)
    println filepath
    local icon = Bitmap( File(filepath) )
    File( filepath ).save( new_icon.cloned.[ resize(icon.size) ].to_png_bytes )
  endForEach
endRoutine

routine rogo_keystore
  println @|
           |===========================================================================================
           |Create Keystore
           |===========================================================================================
           |The following steps will create a new Android keystore suitable for using as a release key
           |or as an upload key. If you elect to use App Signing by Google Play, the first key you sign
           |your app with will become your "upload key" and should be used for all subsequent uploads
           |to Google Play.
           |
           |The passwords you enter are used for the 'keytool' software and are also stored in
           |Platforms/Android/BuildLocal.rogue for building 'rogo android release'. Be sure and store
           |your keystore and passwords in permanent and private location.
           |
           |If you prefer you can CTRL+C now and manually create a keystore with the following command:
           |
           |  keytool -genkey -v -keystore <filepath.keystore> -storepass <keystore-password> \
           |  -alias <key-alias> -keypass <key-password> -keyalg RSA -validity 36500
           |
  local keystore_filepath = File( Console.input( "Enter keystore filepath (can use ~): " ) ).resolved.filepath
  if (File(keystore_filepath).exists)
    throw Error( "Keystore $ already exits - if\nyou wish to overwrite it, manually delete and retry." (keystore_filepath) )
  endIf

  local keystore_password = Console.input( "Enter keystore password: " )
  local key_alias    = Console.input( "Enter key alias (default: 'appsign'): " )
  if (key_alias == "") key_alias = "appsign"
  local key_password = Console.input( "Enter key password: " )
  local keystore_folder = File( keystore_filepath ).folder
  if (not File(keystore_folder).exists)
    println "Creating folder " + keystore_folder
    File( keystore_folder ).create_folder
  endIf
  execute "keytool -genkey -v -keystore $ -storepass $ -alias $ -keypass $ -keyalg RSA -validity 36500" ...
    (File(keystore_filepath).esc,keystore_password,key_alias,key_password)
  local build_local = ""
  if (File("BuildLocal.rogue").exists)
    println "Appending Keystore info to Platforms/Android/BuildLocal.rogue"
    build_local = String( File("BuildLocal.rogue") ) + "\n"
  else
    println "Creating Platforms/Android/BuildLocal.rogue with keystore info."
  endIf
  build_local += ''augment Keystore\n''
  build_local += ''  METHODS\n''
  build_local += ''    method init\n''
  build_local += ''      keystore_filepath = "$"\n'' (keystore_filepath)
  build_local += ''      keystore_password = "$"\n'' (keystore_password)
  build_local += ''      key_alias         = "$"\n'' (key_alias)
  build_local += ''      key_password      = "$"\n'' (key_password)
  build_local += ''endAugment\n''
  File( "BuildLocal.rogue" ).save( build_local )

  Keystore.keystore_filepath = keystore_filepath
  Keystore.keystore_password = keystore_password
  Keystore.key_alias         = key_alias
  Keystore.key_password      = key_password
endRoutine

routine rogo_build_debug
  configure_local_properties
  execute "gradle assembleDebug"
endRoutine

routine rogo_build_release
  configure_local_properties
  execute "gradle assembleRelease"
endRoutine

routine rogo_debug
  rogo_build_debug
  if (not Process.run("adb version",&env).success)
    throw Error( "You must install the Android command line tool 'adb' and add it to your path." )
  endIf
  local package = String(File("app/build.gradle")).extract_string(''*\napplicationId "$"\n*'')
  local apk_filepath = "app/build/outputs/apk/debug/app-debug.apk"

  uninstall( package )
  install( apk_filepath )

  local launch_timestamp = "$-$ $" (Date.today.month.format("02"),Date.today.day.format("02"),Time.now->String("hh:mm:ss.ms"))
  local launchable_activity = package + ".MainActivity"
  execute( "adb shell am start -n $/$" (package,launchable_activity) )

  println "-" * 79
  println "LOGCAT (CTRL+C to exit)"
  println "-" * 79

  local check_timestamp = true

  local ps_info : String?
  loop 5
    ps_info = Process.run( "adb shell ps", &env, &writable )->String.split( '\n' ).find( (f) with (package) => f.contains(package) )
    if (ps_info.exists) escapeLoop
  endLoop
  assert ps_info.exists
  local pid = ps_info.value.from_first(' ').trimmed.before_first(' ')  # second value is PID

  println "Logging process " + pid
  println ps_info
  local process = Process( "adb logcat", &readable, &writable, &env )
  local reader = LineReader( process.output_reader )
  while (not process.is_finished)
    forEach (line in reader)
      local has_pid = line.contains( pid )
      if (has_pid)
        local i = line.locate( ' ' )
        if (i.exists) i = line.locate( ' ', i.value+1 )
        has_pid = i.exists and line.contains_at( pid, i.value+1 )
      endIf
      if (has_pid or line.contains("AndroidRuntime"))
        if (check_timestamp)
          local i = line.locate( ' ' )
          if (i.exists) i = line.locate( ' ', i.value+1 )
          if (i.exists)
            local timestamp = line.leftmost( i.value )
            if (timestamp > launch_timestamp) check_timestamp = false; println line
          endIf
        else
          println line
        endIf
      endIf
    endForEach
    System.sleep( 0.1 )
  endWhile

endRoutine

routine rogo_release
  Keystore.configure

  rogo_build_release

  if (not Process.run("aapt v",&env).success)
    throw Error( "You must install the Android command line tool 'aapt' and add it to your path." )
  endIf

  local result = Process.run( "aapt dump badging app/build/outputs/apk/release/app-release-unsigned.apk", &env )
  assert result.success
  local path = "app/build/outputs/apk/release"
  local aligned_apk = path + "app-release-unsigned-aligned.apk"
  File( aligned_apk ).delete
  if (not execute("zipalign -p 4 $/app-release-unsigned.apk $"(path,aligned_apk), &suppress_error))
    throw Error( "Ensure that 'zipalign' is the system path and can be run from the command line." )
  endIf

  local strings = result->String.extract_strings( "* name='$' versionCode='$' versionName='$'*" )
  local signed_apk = "$/$-v$.apk" (path,strings[0].after_any('.'),strings[1])
  File( signed_apk ).delete

  local cmd = "apksigner sign --ks $ --v1-signing-enabled true --v2-signing-enabled true" (File(Keystore.keystore_filepath).esc)
  if (Keystore.keystore_password) cmd += " --ks-pass pass:"  + Keystore.keystore_password
  if (Keystore.key_alias)         cmd += " --ks-key-alias "  + Keystore.key_alias
  if (Keystore.key_password)      cmd += " --key-pass pass:" + Keystore.key_password
  cmd += " --out $ $" (signed_apk,aligned_apk)
  execute cmd

  execute "apksigner verify $" (signed_apk)

  println
  println "-" * 79
  println ''"META-INF" warnings are normal and can be disregarded.''
  println "-" * 79
  println

  println "Signed APK:"
  println signed_apk

endRoutine

routine uninstall( package:String )
  local output = Process.run( "adb shell pm list packages", &env, &writable )->String
  forEach (line in LineReader(output))
    if (line.after_first("package:").trimmed == package)
      execute( "adb uninstall $" (package) )
      return
    endIf
  endForEach
endRoutine

routine install( filepath:String )
  execute( "adb install "+ filepath )
endRoutine

routine configure_local_properties
  local local_properties_filepath = "local.properties"
  if (File(local_properties_filepath).exists) return

  # Attempt to locate Android SDK
  local sdk_folder : String
  contingent
    sdk_folder = System.env["ANDROID_HOME"]
    sufficient (sdk_folder and File(sdk_folder).is_folder)

    sdk_folder = "~/Library/Android/sdk"
    sufficient (File(sdk_folder).is_folder)

    sdk_folder = "/Library/Android/sdk"
    sufficient (File(sdk_folder).is_folder)

    sdk_folder = null
    escapeContingent

  satisfied
    sdk_folder = File( sdk_folder ).abs.filepath

  endContingent

  local builder = String()
  builder.println @|# Do NOT check this file into your version control system as it contains
                   |# information specific to your local configuration.
                   |#
                   |# Location of the Android SDK. This is only used by Gradle and Android Studio.
  builder.println( "# " + Date.today )
  if (sdk_folder) builder.println"sdk.dir=$" (sdk_folder)
  else            builder.println"#sdk.dir=<folder>  # Specify the correct folder and uncomment this line"
  println "Creating local.properties with SDK location."
  File( local_properties_filepath ).save( builder )

  if (not sdk_folder)
    local mesg = "Cannot locate the Android SDK. Please install them and then edit the "...
                 "corresponding paths in 'Platforms/Android/local.properties'."
    if (System.is_linux)
      mesg += "\n\nYou can install the Android SDK with:\nsudo apt install android-sdk"
    endIf
    throw Error( mesg )
  endIf
endRoutine

routine execute( commands:String, &suppress_error )->Logical
  forEach (cmd in LineReader(commands))
    print( "> " )
    println( cmd )
    if (System.run(cmd) != 0)
      if (suppress_error) return false
      else                throw Error( "Build failed." )
    endIf
  endForEach
  return true
endRoutine

#-------------------------------------------------------------------------------
# Introspection-based Launcher Framework
#-------------------------------------------------------------------------------
# Rogo is a "build your own build system" facilitator. At its core Rogo just
# recompiles build files if needed and then runs the build executable while
# forwarding any command line arguments. This file contains a default framework
# which uses introspection to turn command line arguments into parameterized
# routine calls.

# Example: to handle the command "rogo abc xyz 5", define
# "routine rogo_abc_xyz( n:Int32 )".

# "rogo_default" will run in the absence of any other command line argument.

# The following "comment directives" can be used in this file to control how
# RogueC compiles it and to manage automatic dependency installation and
# linking.

# Each of the following should be on a line beginning with the characters #$
# (preceding whitespace is fine). Sample args are given.

#   ROGUEC       = roguec       # Path to roguec to compile this file with
#   ROGUEC_ARGS  = --whatever   # Additional options to pass to RogueC
#   CC           = gcc -Wall -fno-strict-aliasing
#   CC_ARGS      = -a -b -c          # Additional C args
#   LINK         = -lalpha -lbeta    # Link this build file with these options
#   LINK(macOS)  = ...               # Options applying only to
#                                    # System.os=="macOS" (use with any OS and
#                                    # any comment directive)
#   LINK_LIBS    = true              # Links following LIBRARIES with this Build
#                                    # file (otherwise just installs them)
#   LINK_LIBS    = false             # Linking turned off for following
#                                    # LIBRARIES - info can still be obtained
#                                    # from $LIBRARY_FLAGS or $LIBRARIES(libname,...)
#   LIBRARIES    = libalpha
#   LIBRARIES    = libbeta(library-name)
#   LIBRARIES    = libfreetype6-dev(freetype2)
#   DEPENDENCIES = Library/Rogue/**/*.rogue
#
#   LIBRARIES    = name(package)
#   LIBRARIES    = name(package:<package> install:<install-cmd>
#                  link:<link-flags> which:<which-name>)
#
# The following macro is replaced within this file (Build.rogue) - the libraries
# should normally also be declared in #$ LIBRARIES:
#
#   $LIBRARY_FLAGS(lib1,lib2)                              # sample macro
#     ->
#   -Ipath/to/lib1/include -Lpath/to/lib1/library -I ...   # sample replacement

routine syntax( command:String, text:String )
  Build.rogo_syntax[ command ] = text
endRoutine

routine description( command:String, text:String )
  Build.rogo_descriptions[ command ] = text
endRoutine

routine help( command:String, description_text=null:String, syntax_text=null:String )
  if (description_text) description( command, description_text )
  if (syntax_text)      syntax( command, syntax_text )
endRoutine

try
  Build.launch
catch (err:Error)
  Build.rogo_error = err
  Build.on_error
endTry

class Build [singleton]
  PROPERTIES
    rogo_syntax         = [String:String]
    rogo_descriptions   = [String:String]
    rogo_prefix         = "rogo_"
    rogo_command        = "default"
    rogo_args           = @[]
    rogo_error          : Error

    LOCAL_SETTINGS_FILE = "Local.settings"

  METHODS
    method launch
      rogo_args.add( forEach in System.command_line_arguments )
      read_defs
      on_launch
      parse_args
      dispatch_command

    method dispatch_command
      local m = find_command( rogo_command )
      if (not m) throw Error( "No such routine rogo_$()" (rogo_command) )

      local args = @[]
      forEach (arg in rogo_args)
        which (arg)
          case "true":  args.add( true )
          case "false": args.add( false )
          case "null":  args.add( null )
          others:       args.add( arg )
        endWhich
      endForEach
      m( args )

    method find_command( name:String )->MethodInfo
      return <<Routine>>.find_global_method( rogo_prefix + name )

    method on_error
      local w = Console.width.or_smaller( 80 )
      Console.error.println "=" * w
      Console.error.println rogo_error
      Console.error.println "=" * w
      on_exit
      System.exit 1

    method on_command_found
      noAction

    method on_command_not_found
      local w = Console.width.or_smaller( 80 )
      println "=" * w
      println "ERROR: No such command '$'." (rogo_args.first)
      println "=" * w
      println
      rogo_command = "help"
      rogo_args.clear
      on_command_found

    method on_launch
      noAction

    method on_exit
      noAction

    method parse_args
      block
        if (rogo_args.count)
          local parts = String[]
          parts.add( forEach in rogo_args )
          rogo_args.clear

          while (parts.count)
            local cmd = parts.join("_")
            if (find_command(cmd))
              rogo_command = cmd
              on_command_found
              escapeBlock
            endIf
            rogo_args.insert( parts.remove_last )
          endWhile

          on_command_not_found
        endIf

        # Use default command
        on_command_found
      endBlock

    method read_defs
      read_defs( LOCAL_SETTINGS_FILE )

    method read_defs( defs_filepath:String )
      # Attempt to read defs from Local.settings
      local overrides = String[]
      if (File(defs_filepath).exists)
        forEach (line in LineReader(File(defs_filepath)))
          if (line.contains("="))
            local name  = line.before_first('=').trimmed
            local value = line.after_first('=').trimmed
            if (value.begins_with('"') or value.begins_with('\''))
              value = value.leftmost(-1).rightmost(-1)
            endIf
            local p = <<Build>>.find_property( name )
            if (p)
              overrides.add( "$ = $" (name,value) )
              p.set_value( this, value )
            endIf
          endIf
        endForEach
      endIf

    method _join( value:Value )->String
      local args = String[]
      args.add( forEach in value )
      return args.join( "_" )
endClass


routine rogo_help( command="":String )
  # SYNTAX: rogo help [command]
  # Displays help for a specified command or else all build commands.
  command = Build._join( Build.rogo_args )
  if (command.count)
    local syntax = get_syntax( command )
    local success = false
    if (syntax)
      println "SYNTAX"
      println "  " + syntax
      println
      success = true
    endIf
    local description = get_description( command )
    if (description)
      local max_w = Console.width - 2
      println "DESCRIPTION"
      forEach (line in LineReader(description.word_wrapped(max_w)))
        print( "  " )
        println( line )
      endForEach
      println
      success = true
    endIf
    if (success)
      return
    else
      local w = Console.width.or_smaller( 80 )
      println "=" * w
      println "ERROR: No such command '$'." (command)
      println "=" * w
      println
    endIf
  endIf

  println "USAGE"
  local entries = CommandInfo[]
  local max_len = 0
  forEach (m in <<Routine>>.global_methods)
    if (m.name.begins_with(Build.rogo_prefix))
      local name = m.name.after_first( Build.rogo_prefix )
      local entry = CommandInfo( name, get_syntax(name), get_description(name) )
      max_len .= or_larger( entry.syntax.count )
      entries.add entry
    endIf
  endForEach

  entries.sort( $1.name < $2.name )
  max_len += 2

  local max_w = Console.width
  forEach (entry in entries)
    print "  " + entry.syntax
    if (entry.@description)
      local description = entry.@description
      loop (max_len - entry.syntax.count) print ' '
      contingent
        sufficient (max_len + description.count <= max_w)
        if (description.contains(". "))
          description = description.before_first( ". " ) + "."
          sufficient (max_len + description.count <= max_w)
        endIf
        necessary (max_len + 10 <= max_w)
        description = description.unright( (description.count - (max_w - max_len))+3 ) + "..."
      satisfied
        print description
      endContingent
    endIf
    println
  endForEach
  println
endRoutine

routine get_syntax( m_name:String )->String
  if (Build.rogo_syntax.contains(m_name))
    return "rogo " + Build.rogo_syntax[ m_name ]
  else
    local m = <<Routine>>.find_global_method( Build.rogo_prefix + m_name )
    if (not m) return null
    local line = "rogo $" (m_name.replacing('_',' '))
    line += " <$>" ((forEach in m.parameters).name)
    return line
  endIf
endRoutine


routine get_description( m_name:String )->String
  if (Build.rogo_descriptions.contains(m_name))
    return Build.rogo_descriptions[ m_name ]
  else
    return null
  endIf
endRoutine

class CommandInfo( name:String, syntax:String, description:String );
